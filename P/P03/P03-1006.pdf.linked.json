{"sections":[{"title":"Generalized Algorithms for Constructing Statistical Language Models Cyril Allauzen, Mehryar Mohri, Brian Roark AT&T Labs – Research 180 Park Avenue Florham Park, NJ 07932, USA ","paragraphs":["allauzen,mohri,roark @research.att.com"]},{"title":"Abstract","paragraphs":["Recent text and speech processing applications such as speech mining raise new and more general problems related to the construction of language models. We present and describe in detail several new and efficient algorithms to address these more general problems and report experimental results demonstrating their usefulness. We give an algorithm for computing efficiently the expected counts of any sequence in a word lattice output by a speech recognizer or any arbitrary weighted automaton; describe a new technique for creating exact representations of","-gram language models by weighted automata whose size is practical for offline use even for a vocabulary size of about 500,000 words and an","-gram order ","; and present a simple and more general technique for constructing class-based language models that allows each class to represent an arbitrary weighted automaton. An efficient implementation of our algorithms and techniques has been incorporated in a general software library for language modeling, the GRM Library, that includes many other text and grammar processing functionalities."]},{"title":"1 Motivation","paragraphs":["Statistical language models are crucial components of many modern natural language processing systems such as speech recognition, information extraction, machine translation, or document classification. In all cases, a language model is used in combination with other information sources to rank alternative hypotheses by as-signing them some probabilities. There are classical techniques for constructing language models such as","- gram models with various smoothing techniques (see Chen and Goodman (1998) and the references therein for a survey and comparison of these techniques).","In some recent text and speech processing applications, several new and more general problems arise that are related to the construction of language models. We present new and efficient algorithms to address these more general problems.","Counting. Classical language models are constructed by deriving statistics from large input texts. In speech mining applications or for adaptation purposes, one often needs to construct a language model based on the output of a speech recognition system. But, the output of a recognition system is not just text. Indeed, the word error rate of conversational speech recognition systems is still too high in many tasks to rely only on the one-best output of the recognizer. Thus, the word lattice output by speech recognition systems is used instead because it contains the correct transcription in most cases.","A word lattice is a weighted finite automaton (WFA) output by the recognizer for a particular utterance. It contains typically a very large set of alternative transcription sentences for that utterance with the corresponding weights or probabilities. A necessary step for constructing a language model based on a word lattice is to derive the statistics for any given sequence from the lattices or WFAs output by the recognizer. This cannot be done by simply enumerating each path of the lattice and counting the number of occurrences of the sequence considered in each path since the number of paths of even a small automaton may be more than four billion. We present a simple and efficient algorithm for computing the expected count of any given sequence in a WFA and report experimental results demonstrating its efficiency.","Representation of language models by WFAs. Classical","-gram language models admit a natural representation by WFAs in which each state encodes a left context of width less than",". However, the size of that representation makes it impractical for offline optimizations such as those used in large-vocabulary speech recognition or general information extraction systems. Most offline representations of these models are based instead on an approximation to limit their size. We describe a new technique for creating an exact representation of","-gram language models by WFAs whose size is practical for offline use even in tasks with a vocabulary size of about 500,000 words and for",".","Class-based models. In many applications, it is natural and convenient to construct class-based language models, that is models based on classes of words (Brown et al., 1992). Such models are also often more robust since they may include words that belong to a class but that were not found in the corpus. Classical class-based models are based on simple classes such as a list of words. But new clustering algorithms allow one to create more general and more complex classes that may be regular languages. Very large and complex classes can also be defined using regular expressions. We present a simple and more general approach to class-based language models based on general weighted context-dependent rules (Kaplan and Kay, 1994; Mohri and Sproat, 1996). Our approach allows us to deal efficiently with more complex classes such as weighted regular languages.","We have fully implemented the algorithms just mentioned and incorporated them in a general software library for language modeling, the GRM Library, that includes many other text and grammar processing functionalities (Allauzen et al., 2003). In the following, we will present in detail these algorithms and briefly describe the corresponding GRM utilities."]},{"title":"2 Preliminaries Definition 1","paragraphs":["A system"," ","is a semiring","(Kuich and Salomaa, 1986) if: ","is a commuta-","tive monoid with identity element",";","","is a monoid","with identity element",";","distributes over","; and","is an","annihilator for",": for all ","","",". Thus, a semiring is a ring that may lack negation. Two semirings often used in speech processing are: the log semiring","","(Mohri, 2002) which is isomorphic to the familiar real or probability semiring","via a","morphism with, for all",":","  ","","and the convention that:","","","and"," , and the tropical semiring","","which can be derived from the log","semiring using the Viterbi approximation.","Definition 2 A weighted finite-state transducer","over a","semiring","is an 8-tuple","where:","is the finite input alphabet of the transducer;"," is the finite output alphabet;","is a finite set of states;","","the set of initial states;","the set of final","states;","a finite","set of transitions;","the initial weight function;","and","the final weight function mapping","to"," .","A Weighted automaton","is de-","fined in a similar way by simply omitting the output la-","bels. We denote by","the set of strings accepted","by an automaton","and similarly by","the strings de-","scribed by a regular expression",".","Given a transition , we denote by","","its input","label,","","its origin or previous state and","","its desti-","nation state or next state, ","its weight,","","its output","label (transducer case). Given a state",", we denote","by","","the set of transitions leaving",".","A path","is an element of","with con-","secutive transitions:","","",",",". We","extend","and","to paths by setting:","","","","","and","","","",". A cycle is a path whose origin and","destination states coincide:","","",". We denote by ","","the set of paths from","to","and by   and "," the set of paths from","to","with in-","put label  and output label","(transducer case).","These definitions can be extended to subsets",",","by:   ","",". The label-","ing functions (and similarly",") and the weight func-","tion","can also be extended to paths by defining the la-","bel of a path as the concatenation of the labels of its","constituent transitions, and the weight of a path as the","","-product of the weights of its constituent transitions:","","","",""," ","","",",","","","","","","","",". We","also extend to any finite set of paths","by setting:","",""," ","",". The output weight associated by","","to each input string","is:   ","","","","","","","","","","    ","is defined to be","when  ",". Simi-","larly, the output weight associated by a transducer","to a","pair of input-output string is:   ","","","","  ","","","","","    ","","when ","",". A successful path in a weighted automaton or transducer","is a path from an initial state to a final state.","is unambiguous if for any string","there is at most one successful path labeled with",". Thus, an unambiguous transducer defines a function. For any transducer",", denote by","the automaton obtained by projecting","on its output, that is by omitting its input labels. Note that the second operation of the tropical semiring and the log semiring as well as their identity elements are identical. Thus the weight of a path in an automaton over the tropical semiring does not change if","is viewed as a weighted automaton over the log semiring or viceversa."]},{"title":"3 Counting","paragraphs":["This section describes a counting algorithm based on general weighted automata algorithms. Let"," ","be an arbitrary weighted automaton over the probability semiring and let","be a regular expression defined over the alphabet",". We are interested in counting the occurrences of the sequences in","while taking into account the weight of the paths where they appear. 3.1 Definition When","is deterministic and pushed, or stochastic, it can be viewed as a probability distribution  over all strings 0 a:e/1b:e/1 1/1X:X/1 a:e/1b:e/1","Figure 1: Counting weighted transducer","with"," . The transition weights and the final weight at state","","are all equal to",".","",".1 The weight","","","","associated by","to each string","is then  ",". Thus, we define the count of the sequence","","in",", ",", as:      ","   "," where    denotes the number of occurrences of","in the string ",", i.e., the expected number of occurrences of","given",". More generally, we will define the count of","as","above regardless of whether","is stochastic or not.","In most speech processing applications,","may be an","acyclic automaton called a phone or a word lattice out-","put by a speech recognition system. But our algorithm is","general and does not assume","to be acyclic. 3.2 Algorithm We describe our algorithm for computing the expected counts of the sequences","and give the proof of its correctness. Let","be the formal power series (Kuich and Salomaa, 1986)","over the probability semiring defined by","     , where",".","Lemma 1 For all","",",  ","","     . Proof. By definition of the multiplication of power series in the probability semiring:","","  ","","           ","  ","     This proves the lemma. ","is a rational power series as a product and closure of the polynomial power series ","and","(Salomaa and Soittola, 1978; Berstel and Reutenauer, 1988). Similarly, since","is regular, the weighted transduction defined by ","is rational. Thus, by the theorem of Schützenberger (Schützenberger, 1961), there exists a weighted transducer","defined over the alphabet ","and the probability semiring realizing that transduction. Figure 1 shows the transducer","in the particular case of",".","1","There exist a general weighted determinization and weight pushing algorithms that can be used to create a deterministic and pushed automaton equivalent to an input word or phone lattice (Mohri, 1997). Proposition 1 Let","be a weighted automaton over the probability semiring, then:","","","  ","","","","Proof. By definition of",", for any","",",","","","","","","","","",", and by lemma 1,","","  ","     . Thus, by definition of composition:","","   ","","","","","","    ","","    ","     ","","","","  ","",""," This ends the proof of the proposition. The proposition gives a simple algorithm for computing the expected counts of","in a weighted automaton based on two general algorithms: composition (Mohri et al., 1996) and projection of weighted transducers. It is also based on the transducer","which is easy to construct. The size of","is in","       ","",", where","is a finite","automaton accepting . With a lazy implementation of","",", only one transition can be used instead of   ",", thereby","reducing the size of the representation of","to"," ","  ","",".","The weighted automaton","","","","contains","-","transitions. A general -removal algorithm can be used","to compute an equivalent weighted automaton with no","-","transition. The computation of","","","","","for a given","is","done by composing with an automaton representing","and by using a simple shortest-distance algorithm (Mohri,","2002) to compute the sum of the weights of all the paths","of the result.","For numerical stability, implementations often replace","probabilities with probabilities. The algorithm just","described applies in a similar way by taking","of the","weights of","(thus all the weights of","will be zero in","that case) and by using the log semiring version of com-","position and","-removal. 3.3 GRM Utility and Experimental Results An efficient implementation of the counting algorithm was incorporated in the GRM library (Allauzen et al., 2003). The GRM utility grmcount can be used in particular to generate a compact representation of the expected counts of the","-gram sequences appearing in a word lattice (of which a string encoded as an automaton is a special case), whose order is less or equal to a given integer. As an example, the following command line:","grmcount -n3 foo.fsm > count.fsm creates an encoded representation count.fsm of the","- gram sequences,",", which can be used to construct a trigram model. The encoded representation itself is also given as an automaton that we do not describe here.","The counting utility of the GRM library is used in a variety of language modeling and training adaptation tasks. Our experiments show that grmcount is quite efficient. We tested this utility with 41,000 weighted automata outputs of our speech recognition system for the same number of speech utterances. The total number of transitions of these automata was","","M. It took about 1h52m, including I/O, to compute the accumulated expected counts of all","-gram,",", appearing in all these automata on a single processor of a 1GHz Intel Pentium processor Linux cluster with 2GB of memory and 256 KB cache. The time to compute these counts represents just  ","th of the total duration of the 41,000 speech utterances used in our experiment."]},{"title":"4 Representation of -gram Language Models with WFAs","paragraphs":["Standard smoothed","-gram models, including backoff (Katz, 1987) and interpolated (Jelinek and Mercer, 1980) models, admit a natural representation by WFAs in which each state encodes a conditioning history of length less than",". The size of that representation is often prohibitive. Indeed, the corresponding automaton may have     states and    ","transitions. Thus, even if the vocabulary size is just 1,000, the representation of a classical trigram model may require in the worst case up to one billion transitions. Clearly, this representation is even less adequate for realistic natural language processing applications where the vocabulary size is in the order of several hundred thousand words.","In the past, two methods have been used to deal with this problem. One consists of expanding that WFA on-demand. Thus, in some speech recognition systems, the states and transitions of the language model automaton are constructed as needed based on the particular input speech utterances. The disadvantage of that method is that it cannot benefit from offline optimization techniques that can substantially improve the efficiency of a recognizer (Mohri et al., 1998). A similar drawback affects other systems where several information sources are combined such as a complex information extraction system. An alternative method commonly used in many applications consists of constructing instead an approximation of that weighted automaton whose size is practical for offline optimizations. This method is used in many large-vocabulary speech recognition systems.","In this section, we present a new method for creating an exact representation of","-gram language models with WFAs whose size is practical even for very large-vocabulary tasks and for relatively high","-gram orders. Thus, our representation does not suffer from the disadvantages just pointed out for the two classical methods.","We first briefly present the classical definitions of","- gram language models and several smoothing techniques commonly used. We then describe a natural representation of","-gram language models using failure transitions. This is equivalent to the on-demand construction referred to above but it helps us introduce both the approximate solution commonly used and our solution for an exact offline representation. 4.1 Classical Definitions In an","-gram model, the joint probability of a string   ","is given as the product of conditional probabilities: ","  ","","  ","  ","     ","(1) where the conditioning history ","","consists of zero or more","words immediately preceding","","and is dictated by the","order of the -gram model.","Let"," "," denote the count of","-gram "," and let      be the maximum likelihood probability of given  , estimated from counts.  ","is often adjusted","to reserve some probability mass for unseen","-gram se-","quences. Denote by    ","","the adjusted conditional","probability. Katz or absolute discounting both lead to an","adjusted probability  .","For all -grams     where "," for some  , we refer to   as the backoff","-gram of ",". Conditional probabilities in a backoff model are of the form:","","","","","","","","","","","","        ","(2) where","is a factor that ensures a normalized model. Conditional probabilities in a deleted interpolation model are of the form:","","","","","","","","  ","","","","","","","","","","","","","","","","","","","","(3) where","is the mixing parameter between zero and one. In practice, as mentioned before, for numerical stability,","probabilities are used. Furthermore, due the Viterbi approximation used in most speech processing applications, the weight associated to a string","by a weighted automaton representing the model is the minimum weight of a path labeled with",". Thus, an","-gram language model is represented by a WFA over the tropical semiring. 4.2 Representation with Failure Transitions Both backoff and interpolated models can be naturally represented using default or failure transitions. A failure transition is labeled with a distinct symbol",". It is the default transition taken at state","when","does not admit an outgoing transition labeled with the word considered. Thus, failure transitions have the semantics of otherwise. w wi-2 i-1 w wi-1 iwi wi-1 f wi fwi e f wi Figure 2: Representation of a trigram model with failure transitions.","The set of states of the WFA representing a backoff or","interpolated model is defined by associating a state","","to","each sequence of length less than","found in the corpus:"," ","       ","","     Its transition set","is defined as the union of the following set of failure transitions:            and the following set of regular transitions:            ","","    ","where ","is defined by:","","","","","   ","","","","","","","  ","","","","","","","","","(4) Figure 2 illustrates this construction for a trigram model. Treating","-transitions as regular symbols, this is a deterministic automaton. Figure 3 shows a complete Katz backoff bigram model built from counts taken from the following toy corpus and using failure transitions: ","s b a a a a ","/s"," s b a a a a ","/s"," s a  /s where ","s denotes the start symbol and  /s","the end sym-","bol for each sentence. Note that the start symbol ","s does not label any transition, it encodes the history  s . All transitions labeled with the end symbol ","/s lead to the single final state of the automaton. 4.3 Approximate Offline Representation The common method used for an offline representation of an","-gram language model can be easily derived from the representation using failure transitions by simply replac-ing each","-transition by an","-transition. Thus, a transition that could only be taken in the absence of any other alternative in the exact representation can now be taken regardless of whether there exists an alternative transition. Thus the approximate representation may contain paths whose weight does not correspond to the exact probability of the string labeling that path according to the model. </s> a </s>/1.101 a/0.405 f/4.856 </s>/1.540 a/0.441 bb/1.945 a/0.287 f/0.356 <s> a/1.108","f/0.231 b/0.693 Figure 3: Example of representation of a bigram model with failure transitions.","Consider for example the start state in figure 3, labeled with ","s",". In a failure transition model, there exists only one path from the start state to the state labeled",", with a cost of 1.108, since the","transition cannot be traversed with an input of",". If the","transition is replaced by an  -transition, there is a second path to the state labeled – taking the","-transition to the history-less state, then the  transition out of the history-less state. This path is not part of the probabilistic model – we shall refer to it as an invalid path. In this case, there is a problem, because the cost of the invalid path to the state – the sum of the two transition costs (0.672) – is lower than the cost of the true path. Hence the WFA with","-transitions gives a lower cost (higher probability) to all strings beginning with the symbol",". Note that the invalid path from the state labeled s","to the state labeled","has a higher cost than the correct path, which is not a problem in the tropical semiring. 4.4 Exact Offline Representation This section presents a method for constructing an exact offline representation of an","-gram language model whose size remains practical for large-vocabulary tasks.","The main idea behind our new construction is to modify the topology of the WFA to remove any path containing","-transitions whose cost is lower than the correct cost associated by the model to the string labeling that path. Since, as a result, the low cost path for each string will have the correct cost, this will guarantee the correctness of the representation in the tropical semiring.","Our construction admits two parts: the detection of the invalid paths of the WFA, and the modification of the topology by splitting states to remove the invalid paths.","To detect invalid paths, we determine first their initial non-","transitions. Let","","denote the set of","-transitions of the original automaton. Let ","","be the set of all paths","",""," ,  ",", leading to state","such","that for all",",",",  ","","is the destination state of","some","-transition. Lemma 2 For an","-gram language model, the number of paths in   is less than the","-gram order:       . Proof. For all ","",", let","","",". By definition,","there is some","","","","such that","","","","","",". By","definition of","-transitions in the model,     ","","for","all",". It follows from the definition of regular transitions","that","  ","","",". Hence,       , i.e. q’ r’ p’ q e r e’ p","Figure 4: The path","is invalid if"," , ","","","",",","  ",", and either (i)  ","and"," "," ","or (ii)","","","and"," "," ",".  "," , for all     . Then,        . The history-less state has no incoming non-","paths, therefore, by recursion,                ","",".","We now define transition sets","  (originally empty)","following this procedure: for all states","","and all","  ",", if there exists another path","and","transition","","such that ","",",","","",",","and","","",", and either (i) ","","and"," ","","","or (ii) there exists","","such that","","","and","  and"," ","","",", then we add","","to","the set:","","","","","","","","","  ","","","","","","",". See figure 4 for","an illustration of this condition. Using this procedure, we","can determine the set:","","","     ",".","This set provides the first non-","transition of each invalid","path. Thus, we can use these transitions to eliminate in-","valid paths. Proposition 2 The cost of the construction of "," ","for all"," is","    ",", where is the n-gram order.","Proof. For each and each   , there are at most   ","possible states","such that for some","",",","","","and"," . It is trivial to see from the proof","of lemma 2 that the maximum length of","is",". Hence,","the cost of finding all for a given","is    . Therefore, the total cost is       . For all non-empty ","  , we create a new state   and for all ","  we set","   . We create a transition  ","",", and for all  ","such that","",",","we set"," ","",". For all","","such that","","and","","","","",""," "," , we set"," ","",". For all","","such that"," ","and ","        ",", we create a new intermediate","backoff state","","and set  ","","; then for all ","",", if","","","","","","    , we add a transition","","","","","","","to",". Proposition 3 The WFA over the tropical semiring modified following the procedure just outlined is equivalent to the exact online representation with failure transitions. Proof. Assume that there exists a string","for which the WFA returns a weight    ","less than the correct weight","","","","that would have been assigned to","by the exact","online representation with failure transitions. We will","call an","-transition  within a path","","","","in-","valid if the next non-transition ",", ",", has the la-","bel",", and there is a transition","with ","","","and b e/0.356 a","a/0.287 a/0.441 e/0 e/4.856 a/0.405 </s> </s>/1.101 <s> b/0.693 a/1.108 e/0.231b/1.945 </s>/1.540 Figure 5: Bigram model encoded exactly with","- transitions.  ",". Let","be a path through the WFA such that   ","and","    ",", and","has the least number","of invalid","-transitions of all paths labeled with","with","weight ","","","",". Let be the last invalid","-transition taken","in path",". Let","be the valid path leaving","","such that","","","","","   .","","","","","","","","",", otherwise","there would be a path with fewer invalid","-transitions with","weight ","","","",". Let","be the first state where paths","","and","","","  intersect. Then",""," ","","for some","",". By definition,     , since intersection will occur","before any","-transitions are traversed in",". Then it must","be the case that","","     ","","","","",", requiring the path to","be removed from the WFA. This is a contradiction. 4.5 GRM Utility and Experimental Results Note that some of the new intermediate backoff states (","",") can be fully or partially merged, to reduce the space requirements of the model. Finding the optimal configuration of these states, however, is an NP-hard problem. For our experiments, we used a simple greedy approach to sharing structure, which helped reduce space dramatically.","Figure 5 shows our example bigram model, after application of the algorithm. Notice that there are now two history-less states, which correspond to","and ","","in the algorithm (no","","was required). The start state backs off to  , which does not include a transition to the state labeled  , thus eliminating the invalid path.","Table 1 gives the sizes of three models in terms of transitions and states, for both the failure transition and  -transition encoding of the model. The DARPA North American Business News (NAB) corpus contains 250 million words, with a vocabulary of 463,331 words. The Switchboard training corpus has 3.1 million words, and a vocabulary of 45,643. The number of transitions needed for the exact offline representation in each case was between 2 and 3 times the number of transitions used in the representation with failure transitions, and the number of states was less than twice the original number of states. This shows that our technique is practical even for very large tasks.","Efficient implementations of model building algorithms have been incorporated into the GRM library. The GRM utility grmmake produces basic backoff models, using Katz or Absolute discounting (Ney et al., 1994) methods, in the topology shown in fig-","Model","-representation exact offline Corpus order arcs states arcs states NAB 3-gram 102752 16838 303686 19033 SWBD 3-gram 2416 475 5499 573 SWBD 6-gram 15430 6295 54002 12374 Table 1: Size of models (in thousands) built from the NAB and Switchboard corpora, with failure transitions ","versus the exact offline representation. ure 3, with","-transitions in the place of failure transitions. The utility grmshrink removes transitions from the model according to the shrinking methods of Seymore and Rosenfeld (1996) or Stolcke (1998). The utility grmconvert takes a backoff model produced by grmmake or grmshrink and converts it into an exact model using either failure transitions or the algorithm just described. It also converts the model to an interpolated model for use in the tropical semiring. As an example, the following command line:","grmmake -n3 counts.fsm > model.fsm creates a basic Katz backoff trigram model from the counts produced by the command line example in the earlier section. The command:","grmshrink -c1 model.fsm > m.s1.fsm shrinks the trigram model using the weighted difference method (Seymore and Rosenfeld, 1996) with a threshold of 1. Finally, the command: grmconvert -tfail m.s1.fsm > f.s1.fsm outputs the model represented with failure transitions."]},{"title":"5 General class-based language modeling","paragraphs":["Standard class-based or phrase-based language models are based on simple classes often reduced to a short list of words or expressions. New spoken-dialog applications require the use of more sophisticated classes either derived from a series of regular expressions or using general clustering algorithms. Regular expressions can be used to define classes with an infinite number of elements. Such classes can naturally arise, e.g., dates form an infinite set since the year field is unbounded, but they can be easily represented or approximated by a regular expression. Also, representing a class by an automaton can be much more compact than specifying them as a list, especially when dealing with classes representing phone numbers or a list of names or addresses.","This section describes a simple and efficient method for constructing class-based language models where each class may represent an arbitrary (weighted) regular language.","Let","","","","","","be a set of","classes and assume that each class","","corresponds to a stochastic weighted automaton","","defined over the log semiring. Thus, the weight","","","","associated by","to a string","can be in-terpreted as","of the conditional probability      .","Each class  defines a weighted transduction:","  ",""," This can be viewed as a specific obligatory weighted context-dependent rewrite rule where the left and right contexts are not restricted (Kaplan and Kay, 1994; Mohri and Sproat, 1996). Thus, the transduction corresponding to the class","","can be viewed as the application of the following obligatory weighted rewrite rule:","","","   ",""," The direction of application of the rule, left-to-right or right-to-left, can be chosen depending on the task 2",". Thus, these","classes can be viewed as a set of batch rewrite rules (Kaplan and Kay, 1994) which can be compiled into weighted transducers. The utilities of the GRM Library can be used to compile such a batch set of rewrite rules efficiently (Mohri and Sproat, 1996).","Let","be the weighted transducer obtained by compil-ing the rules corresponding to the classes. The corpus can be represented as a finite automaton",". To apply the rules defining the classes to the input corpus, we just need to compose the automaton","with","and project the result on the output:    ","can be made stochastic using a pushing algorithm (Mohri, 1997). In general, the transducer","may not be unambiguous. Thus, the result of the application of the class rules to the corpus may not be a single text but an automaton representing a set of alternative sequences. However, this is not an issue since we can use the general counting algorithm previously described to construct a language model based on a weighted automaton. When  "," ",", the language defined by the classes, is","a code, the transducer","is unambiguous.","Denote now by"," the language model constructed","from the new corpus ",". To construct our final class-","based language model ",", we simply have to compose  with","and project the result on the output side: ","      A more general approach would be to have two transducers","and",", the first one to be applied to the corpus and the second one to the language model. In a probabilistic interpretation,","should represent the probability distribution     "," and","","the probability distribution"," ","","","",". By using  ","and","","",", we are in fact making the assumptions that the classes are equally probable and thus that             ","        ","",".","More generally, the weights of","and","could be the re-","sults of an iterative learning process. Note however that 2 The simultaneous case is equivalent to the left-to-right one","here. 0/0 returns:returns/0 batman:<movie>/0.510","1 batman:<movie>/0.916 returns:e/0 Figure 6: Weighted transducer","obtained from the compilation of context-dependent rewrite rules.","0 1batman 2returns 0 1<movie>/0.510 3<movie>/0.916 2/0returns/0 e/0","Figure 7: Corpora","and","",".","we are not limited to this probabilistic interpretation and","that our approach can still be used if","and","do not","represent probability distributions, since we can always","push","","and normalize . Example. We illustrate this construction in the simple case of the following class containing movie titles:","","movie","","batman ","batman returns",""," The compilation of the rewrite rule defined by this class and applied left to right leads to the weighted transducer  given by figure 6. Our corpus simply consists of the sentence “batman returns” and is represented by the automaton","given by figure 7. The corpus","","obtained by composing","with","is given by figure 7."]},{"title":"6 Conclusion","paragraphs":["We presented several new and efficient algorithms to deal with more general problems related to the construction of language models found in new language processing applications and reported experimental results show-ing their practicality for constructing very large models. These algorithms and many others related to the construction of weighted grammars have been fully implemented and incorporated in a general grammar software library, the GRM Library (Allauzen et al., 2003)."]},{"title":"Acknowledgments","paragraphs":["We thank Michael Riley for discussions and for having implemented an earlier version of the counting utility."]},{"title":"References","paragraphs":["Cyril Allauzen, Mehryar Mohri, and Brian Roark. 2003. GRM Library-Grammar Library. http://www.research.att.com/sw/tools/grm, AT&T Labs - Research.","Jean Berstel and Christophe Reutenauer. 1988. Rational Series and Their Languages. Springer-Verlag: Berlin-New York.","Peter F. Brown, Vincent J. Della Pietra, Peter V. deSouza, Jennifer C. Lai, and Robert L. Mercer. 1992. Class-based n-gram models of natural language. Computational Linguistics, 18(4):467–479.","Stanley Chen and Joshua Goodman. 1998. An empirical study of smoothing techniques for language modeling. Technical Report, TR-10-98, Harvard University.","Frederick Jelinek and Robert L. Mercer. 1980. Interpolated estimation of markov source parameters from sparse data. In Proceedings of the Workshop on Pattern Recognition in Practice, pages 381–397.","Ronald M. Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3).","Slava M. Katz. 1987. Estimation of probabilities from sparse data for the language model component of a speech recogniser. IEEE Transactions on Acoustic, Speech, and Signal Processing, 35(3):400–401.","Werner Kuich and Arto Salomaa. 1986. Semirings, Automata, Languages. Number 5 in EATCS Monographs on Theoretical Computer Science. Springer-Verlag, Berlin, Germany.","Mehryar Mohri and Richard Sproat. 1996. An Efficient Compiler for Weighted Rewrite Rules. In","th Meeting of the Association for Computational Linguistics (ACL ’96), Proceedings of the Conference, Santa Cruz, California. ACL.","Mehryar Mohri, Fernando C. N. Pereira, and Michael Riley. 1996. Weighted Automata in Text and Speech Processing. In Proceedings of the 12th biennial European Conference on Artificial Intelligence (ECAI-96), Workshop on Extended finite state models of language, Budapest, Hungary. ECAI.","Mehryar Mohri, Michael Riley, Don Hindle, Andrej Ljolje, and Fernando C. N. Pereira. 1998. Full expansion of context-dependent networks in large vocabulary speech recognition. In Proceedings of the International Conference on Acoustics, Speech, and Signal Processing (ICASSP).","Mehryar Mohri. 1997. Finite-State Transducers in Language and Speech Processing. Computational Linguistics, 23:2.","Mehryar Mohri. 2002. Semiring Frameworks and Algorithms for Shortest-Distance Problems. Journal of Automata, Languages and Combinatorics, 7(3):321–350.","Hermann Ney, Ute Essen, and Reinhard Kneser. 1994. On structuring probabilistic dependences in stochastic language modeling. Computer Speech and Language, 8:1–38.","Arto Salomaa and Matti Soittola. 1978. Automata-Theoretic Aspects of Formal Power Series. Springer-Verlag: New York.","Marcel Paul Schützenberger. 1961. On the definition of a family of automata. Information and Control, 4.","Kristie Seymore and Ronald Rosenfeld. 1996. Scalable backoff language models. In Proceedings of the International Conference on Spoken Language Processing (ICSLP).","Andreas Stolcke. 1998. Entropy-based pruning of backoff language models. In Proc. DARPA Broadcast News Transcrip-tion and Understanding Workshop, pages 270–274."]}],"references":[{"authors":[{"first":"Cyril","last":"Allauzen"},{"first":"Mehryar","last":"Mohri"},{"first":"Brian","last":"Roark"}],"year":"2003","title":"GRM Library-Grammar Library","source":"Cyril Allauzen, Mehryar Mohri, and Brian Roark. 2003. GRM Library-Grammar Library. http://www.research.att.com/sw/tools/grm, AT&T Labs - Research."},{"authors":[{"first":"Jean","last":"Berstel"},{"first":"Christophe","last":"Reutenauer"}],"year":"1988","title":"Rational Series and Their Languages","source":"Jean Berstel and Christophe Reutenauer. 1988. Rational Series and Their Languages. Springer-Verlag: Berlin-New York."},{"authors":[{"first":"Peter","middle":"F.","last":"Brown"},{"first":"Vincent","middle":"J. Della","last":"Pietra"},{"first":"Peter V","middle":".","last":"deSouza"},{"first":"Jennifer","middle":"C.","last":"Lai"},{"first":"Robert","middle":"L.","last":"Mercer"}],"year":"1992","title":"Class-based n-gram models of natural language","source":"Peter F. Brown, Vincent J. Della Pietra, Peter V. deSouza, Jennifer C. Lai, and Robert L. Mercer. 1992. Class-based n-gram models of natural language. Computational Linguistics, 18(4):467–479."},{"authors":[{"first":"Stanley","last":"Chen"},{"first":"Joshua","last":"Goodman"}],"year":"1998","title":"An empirical study of smoothing techniques for language modeling","source":"Stanley Chen and Joshua Goodman. 1998. An empirical study of smoothing techniques for language modeling. Technical Report, TR-10-98, Harvard University."},{"authors":[{"first":"Frederick","last":"Jelinek"},{"first":"Robert","middle":"L.","last":"Mercer"}],"year":"1980","title":"Interpolated estimation of markov source parameters from sparse data","source":"Frederick Jelinek and Robert L. Mercer. 1980. Interpolated estimation of markov source parameters from sparse data. In Proceedings of the Workshop on Pattern Recognition in Practice, pages 381–397."},{"authors":[{"first":"Ronald","middle":"M.","last":"Kaplan"},{"first":"Martin","last":"Kay"}],"year":"1994","title":"Regular models of phonological rule systems","source":"Ronald M. Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3)."},{"authors":[{"first":"Slava","middle":"M.","last":"Katz"}],"year":"1987","title":"Estimation of probabilities from sparse data for the language model component of a speech recogniser","source":"Slava M. Katz. 1987. Estimation of probabilities from sparse data for the language model component of a speech recogniser. IEEE Transactions on Acoustic, Speech, and Signal Processing, 35(3):400–401."},{"authors":[{"first":"Werner","last":"Kuich"},{"first":"Arto","last":"Salomaa"}],"year":"1986","title":"Semirings, Automata, Languages","source":"Werner Kuich and Arto Salomaa. 1986. Semirings, Automata, Languages. Number 5 in EATCS Monographs on Theoretical Computer Science. Springer-Verlag, Berlin, Germany."},{"authors":[{"first":"Mehryar","last":"Mohri"},{"first":"Richard","last":"Sproat"}],"year":"1996","title":"An Efficient Compiler for Weighted Rewrite Rules","source":"Mehryar Mohri and Richard Sproat. 1996. An Efficient Compiler for Weighted Rewrite Rules. In"},{"authors":[],"source":"th Meeting of the Association for Computational Linguistics (ACL ’96), Proceedings of the Conference, Santa Cruz, California. ACL."},{"authors":[{"first":"Mehryar","last":"Mohri"},{"first":"Fernando","middle":"C. N.","last":"Pereira"},{"first":"Michael","last":"Riley"}],"year":"1996","title":"Weighted Automata in Text and Speech Processing","source":"Mehryar Mohri, Fernando C. N. Pereira, and Michael Riley. 1996. Weighted Automata in Text and Speech Processing. In Proceedings of the 12th biennial European Conference on Artificial Intelligence (ECAI-96), Workshop on Extended finite state models of language, Budapest, Hungary. ECAI."},{"authors":[{"first":"Mehryar","last":"Mohri"},{"first":"Michael","last":"Riley"},{"first":"Don","last":"Hindle"},{"first":"Andrej","last":"Ljolje"},{"first":"Fernando","middle":"C. N.","last":"Pereira"}],"year":"1998","title":"Full expansion of context-dependent networks in large vocabulary speech recognition","source":"Mehryar Mohri, Michael Riley, Don Hindle, Andrej Ljolje, and Fernando C. N. Pereira. 1998. Full expansion of context-dependent networks in large vocabulary speech recognition. In Proceedings of the International Conference on Acoustics, Speech, and Signal Processing (ICASSP)."},{"authors":[{"first":"Mehryar","last":"Mohri"}],"year":"1997","title":"Finite-State Transducers in Language and Speech Processing","source":"Mehryar Mohri. 1997. Finite-State Transducers in Language and Speech Processing. Computational Linguistics, 23:2."},{"authors":[{"first":"Mehryar","last":"Mohri"}],"year":"2002","title":"Semiring Frameworks and Algorithms for Shortest-Distance Problems","source":"Mehryar Mohri. 2002. Semiring Frameworks and Algorithms for Shortest-Distance Problems. Journal of Automata, Languages and Combinatorics, 7(3):321–350."},{"authors":[{"first":"Hermann","last":"Ney"},{"first":"Ute","last":"Essen"},{"first":"Reinhard","last":"Kneser"}],"year":"1994","title":"On structuring probabilistic dependences in stochastic language modeling","source":"Hermann Ney, Ute Essen, and Reinhard Kneser. 1994. On structuring probabilistic dependences in stochastic language modeling. Computer Speech and Language, 8:1–38."},{"authors":[{"first":"Arto","last":"Salomaa"},{"first":"Matti","last":"Soittola"}],"year":"1978","title":"Automata-Theoretic Aspects of Formal Power Series","source":"Arto Salomaa and Matti Soittola. 1978. Automata-Theoretic Aspects of Formal Power Series. Springer-Verlag: New York."},{"authors":[{"first":"Marcel","middle":"Paul","last":"Schützenberger"}],"year":"1961","title":"On the definition of a family of automata","source":"Marcel Paul Schützenberger. 1961. On the definition of a family of automata. Information and Control, 4."},{"authors":[{"first":"Kristie","last":"Seymore"},{"first":"Ronald","last":"Rosenfeld"}],"year":"1996","title":"Scalable backoff language models","source":"Kristie Seymore and Ronald Rosenfeld. 1996. Scalable backoff language models. In Proceedings of the International Conference on Spoken Language Processing (ICSLP)."},{"authors":[{"first":"Andreas","last":"Stolcke"}],"year":"1998","title":"Entropy-based pruning of backoff language models","source":"Andreas Stolcke. 1998. Entropy-based pruning of backoff language models. In Proc. DARPA Broadcast News Transcrip-tion and Understanding Workshop, pages 270–274."}],"cites":[{"style":0,"text":"Chen and Goodman (1998)","origin":{"pointer":"/sections/2/paragraphs/1","offset":53,"length":23},"authors":[{"last":"Chen"},{"last":"Goodman"}],"year":"1998","references":["/references/3"]},{"style":0,"text":"Brown et al., 1992","origin":{"pointer":"/sections/2/paragraphs/10","offset":155,"length":18},"authors":[{"last":"Brown"},{"last":"al."}],"year":"1992","references":["/references/2"]},{"style":0,"text":"Kaplan and Kay, 1994","origin":{"pointer":"/sections/2/paragraphs/10","offset":713,"length":20},"authors":[{"last":"Kaplan"},{"last":"Kay"}],"year":"1994","references":["/references/5"]},{"style":0,"text":"Mohri and Sproat, 1996","origin":{"pointer":"/sections/2/paragraphs/10","offset":735,"length":22},"authors":[{"last":"Mohri"},{"last":"Sproat"}],"year":"1996","references":["/references/8"]},{"style":0,"text":"Allauzen et al., 2003","origin":{"pointer":"/sections/2/paragraphs/11","offset":218,"length":21},"authors":[{"last":"Allauzen"},{"last":"al."}],"year":"2003","references":["/references/0"]},{"style":0,"text":"Kuich and Salomaa, 1986","origin":{"pointer":"/sections/3/paragraphs/3","offset":1,"length":23},"authors":[{"last":"Kuich"},{"last":"Salomaa"}],"year":"1986","references":["/references/7"]},{"style":0,"text":"Mohri, 2002","origin":{"pointer":"/sections/3/paragraphs/20","offset":1,"length":11},"authors":[{"last":"Mohri"}],"year":"2002","references":["/references/13"]},{"style":0,"text":"Kuich and Salomaa, 1986","origin":{"pointer":"/sections/4/paragraphs/42","offset":28,"length":23},"authors":[{"last":"Kuich"},{"last":"Salomaa"}],"year":"1986","references":["/references/7"]},{"style":0,"text":"Salomaa and Soittola, 1978","origin":{"pointer":"/sections/4/paragraphs/59","offset":1,"length":26},"authors":[{"last":"Salomaa"},{"last":"Soittola"}],"year":"1978","references":["/references/15"]},{"style":0,"text":"Berstel and Reutenauer, 1988","origin":{"pointer":"/sections/4/paragraphs/59","offset":29,"length":28},"authors":[{"last":"Berstel"},{"last":"Reutenauer"}],"year":"1988","references":["/references/1"]},{"style":0,"text":"Schützenberger, 1961","origin":{"pointer":"/sections/4/paragraphs/61","offset":53,"length":20},"authors":[{"last":"Schützenberger"}],"year":"1961","references":["/references/16"]},{"style":0,"text":"Mohri, 1997","origin":{"pointer":"/sections/4/paragraphs/67","offset":187,"length":11},"authors":[{"last":"Mohri"}],"year":"1997","references":["/references/12"]},{"style":0,"text":"Mohri et al., 1996","origin":{"pointer":"/sections/4/paragraphs/109","offset":70,"length":18},"authors":[{"last":"Mohri"},{"last":"al."}],"year":"1996","references":["/references/10"]},{"style":0,"text":"Allauzen et al., 2003","origin":{"pointer":"/sections/4/paragraphs/155","offset":142,"length":21},"authors":[{"last":"Allauzen"},{"last":"al."}],"year":"2003","references":["/references/0"]},{"style":0,"text":"Katz, 1987","origin":{"pointer":"/sections/5/paragraphs/1","offset":33,"length":10},"authors":[{"last":"Katz"}],"year":"1987","references":["/references/6"]},{"style":0,"text":"Jelinek and Mercer, 1980","origin":{"pointer":"/sections/5/paragraphs/1","offset":63,"length":24},"authors":[{"last":"Jelinek"},{"last":"Mercer"}],"year":"1980","references":["/references/4"]},{"style":0,"text":"Mohri et al., 1998","origin":{"pointer":"/sections/5/paragraphs/4","offset":447,"length":18},"authors":[{"last":"Mohri"},{"last":"al."}],"year":"1998","references":["/references/11"]},{"style":0,"text":"Ney et al., 1994","origin":{"pointer":"/sections/5/paragraphs/466","offset":191,"length":16},"authors":[{"last":"Ney"},{"last":"al."}],"year":"1994","references":["/references/14"]},{"style":0,"text":"Seymore and Rosenfeld (1996)","origin":{"pointer":"/sections/5/paragraphs/470","offset":145,"length":28},"authors":[{"last":"Seymore"},{"last":"Rosenfeld"}],"year":"1996","references":["/references/17"]},{"style":0,"text":"Stolcke (1998)","origin":{"pointer":"/sections/5/paragraphs/470","offset":177,"length":14},"authors":[{"last":"Stolcke"}],"year":"1998","references":["/references/18"]},{"style":0,"text":"Seymore and Rosenfeld, 1996","origin":{"pointer":"/sections/5/paragraphs/472","offset":99,"length":27},"authors":[{"last":"Seymore"},{"last":"Rosenfeld"}],"year":"1996","references":["/references/17"]},{"style":0,"text":"Kaplan and Kay, 1994","origin":{"pointer":"/sections/6/paragraphs/24","offset":139,"length":20},"authors":[{"last":"Kaplan"},{"last":"Kay"}],"year":"1994","references":["/references/5"]},{"style":0,"text":"Mohri and Sproat, 1996","origin":{"pointer":"/sections/6/paragraphs/24","offset":161,"length":22},"authors":[{"last":"Mohri"},{"last":"Sproat"}],"year":"1996","references":["/references/8"]},{"style":0,"text":"Kaplan and Kay, 1994","origin":{"pointer":"/sections/6/paragraphs/33","offset":55,"length":20},"authors":[{"last":"Kaplan"},{"last":"Kay"}],"year":"1994","references":["/references/5"]},{"style":0,"text":"Mohri and Sproat, 1996","origin":{"pointer":"/sections/6/paragraphs/33","offset":229,"length":22},"authors":[{"last":"Mohri"},{"last":"Sproat"}],"year":"1996","references":["/references/8"]},{"style":0,"text":"Mohri, 1997","origin":{"pointer":"/sections/6/paragraphs/39","offset":50,"length":11},"authors":[{"last":"Mohri"}],"year":"1997","references":["/references/12"]},{"style":0,"text":"Allauzen et al., 2003","origin":{"pointer":"/sections/7/paragraphs/0","offset":459,"length":21},"authors":[{"last":"Allauzen"},{"last":"al."}],"year":"2003","references":["/references/0"]}]}
