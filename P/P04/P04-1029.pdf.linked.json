{"sections":[{"title":"Optimizing Typed Feature Structure Grammar Parsing through Non-Statistical Indexing Cosmin Munteanu and Gerald Penn University of Toronto 10 King’s College Rd. Toronto M5S 3G4 Canada mcosmin,gpenn @cs.toronto.edu Abstract","paragraphs":["This paper introduces an indexing method based on static analysis of grammar rules and type signatures for typed feature structure grammars (TFSGs). The static analysis tries to predict at compile-time which feature paths will cause unification failure during parsing at run-time. To support the static analysis, we introduce a new classification of the instances of variables used in TFSGs, based on what type of structure sharing they create. The indexing actions that can be performed during parsing are also enumerated. Non-statistical indexing has the advantage of not requiring training, and, as the evaluation using large-scale HPSGs demonstrates, the improvements are comparable with those of statistical optimizations. Such statistical optimizations rely on data collected during training, and their performance does not always compensate for the training costs."]},{"title":"1 Introduction","paragraphs":["Developing efficient all-paths parsers has been a long-standing goal of research in computational linguistics. One particular class still in need of parsing time improvements is that of TFSGs. While simpler formalisms such as context-free grammars (CFGs) also face slow all-paths parsing times when the size of the grammar increases significantly, TFSGs (which generally have fewer rules than large-scale CFGs) become slow as a result of the complex structures used to describe the grammatical categories. In HPSGs (Pollard and Sag, 1994), one category description could contain hundreds of feature values. This has been a barrier in transferring CFG-successful techniques to TFSG parsing.","For TFSG chart parsers, one of the most time-consuming operations is the retrieval of categories from the chart during rule completion (closing of constituents in the chart under a grammar rule). Looking in the chart for a matching edge for a daughter is accomplished by attempting unifications with edges stored in the chart, resulting in many failed unifications. The large and complex structure of TFS descriptions (Carpenter, 1992) leads to slow unificationtimes, affecting the parsing times. Thus, failing unificationsmust be avoided during retrieval from the chart.","To our knowledge, there have been only four methods proposed for improving the retrieval component of TFSG parsing. One (Penn and Munteanu, 2003) addresses only the cost of copying large categories, and was found to reduce parsing times by an average of 25% on a large-scale TFSG (MERGE). The second, a statistical method known as quick-check (Malouf et al., 2000), determines the paths that are likely to cause unification failure by profiling a large sequence of parses over representative input, and then filters unifications at run-time by first testing these paths for type consistency. This was measured as providing up to a 50% improvement in parse times on the English Resource Grammar (Flickinger, 1999, ERG). The third (Penn, 1999b) is a similar but more conservative approach that uses the profileto re-order sister feature values in the internal data structure. This was found to improve parse times on the ALE HPSG by up to 33%.","The problem with these statistical methods is that the improvements in parsing times may not justify the time spent on profiling, particularly during grammar development. The static analysis method introduced here does not use profiling, although it does not preclude it either. Indeed, an evaluation of statistical methods would be more relevant if measured on top of an adequate extent of non-statistical optimizations. Although quick-check is thought to produce parsing time improvements, its evaluation used a parser with only a superficial static analysis of chart indexing.","That analysis, rule filtering (Kiefer et al., 1999), reduces parse times by filteringout mother-daughter unifications that can be determined to fail at compile-time. True indexing organizes the data (in this case, chart edges) to avoid unnecessary retrievals altogether, does not require the operations that it performs to be repeated once full unification is deemed necessary, and offers the support for easily adding information extracted from further static analysis of the grammar rules, while maintaining the same indexing strategy. Flexibility is one of the reasons for the successful employment of indexing in databases (Elmasri and Navathe, 2000) and automated reasoning (Ramakrishnan et al., 2001).","In this paper, we present a general scheme for indexing TFS categories during parsing (Section 3). We then present a specificmethod for statically an-alyzing TFSGs based on the type signature and the structure of category descriptions in the grammar rules, and prove its soundness and completeness (Section 4.2.1). We describe a specific indexing strategy based on this analysis (Section 4), and evaluate it on two large-scale TFSGs (Section 5). The result is a purely non-statistical method that is competitive with the improvements gained by statistical optimizations, and is still compatible with further statistical improvements."]},{"title":"2 TFSG Terminology","paragraphs":["TFSs are used as formal representatives of rich grammatical categories. In this paper, the formal-ism from (Carpenter, 1992) will be used. A TFSG is defined relative to a fixed set of types and set of features, along with constraints, called appropriateness conditions. These are collectively known as the type signature (Figure 3). For each type, appropriateness specifiesall and only the features that must have values defined in TFSs of that type. It also specifies the types of the values that those features can take. The set of types is partially ordered, and has a unique most general type (","– “bottom”). This order is called subsumption (","): more specific (higher) types inherit appropriate features from their more general (lower) supertypes. Two types t1 and t2 unify (t1","t2 ",") iff they have a least upper bound","in the hierarchy. Besides a type signature, TFSGs","contain a set of grammar (phrase) rules and lexical","descriptions. A simple example of a lexical descrip-","tion is: john","SYNSEM :","SYN : np","SEM : j",", while","an example of a phrase rule is given in Figure 1.","","SYN : s","SEM : V PSem","AGENT : NPSem","","SYN : np AGR : Agr","SEM : NPSem",",","","SYN : vp AGR : Agr","SEM : V PSem",". Figure 1: A phrase rule stating that the syntactic category s can be combined from np and vp if their values for agr are the same. The semantics of s is that of the verb phrase, while the semantics of the noun phrase serves as agent. 2.1 Typed Feature Structures","A TFS (Figure 2) is like a recursively definedrecord","in a programming language: it has a type and fea-","tures with values that can be TFSs, all obeying","the appropriateness conditions of the type signature.","TFSs can also be seen as rooted graphs, where arcs","correspond to features and nodes to substructures. A","node typing function q","q","associates a type to every","node q in a TFS. Every TFS F has a unique starting","or root node, qF . For a given TFS, the feature value","partial function d","f","q","specifiesthe node reachable","from q by feature f when one exists. The path value","partial function d","p","q","specifiesthe node reachable","from q by following a path of features p when one","exists. TFSs can be unifiedas well. The result repre-","sents the most general consistent combination of the","information from two TFSs. That information in-","cludes typing (by unifying the types), feature values","(by recursive unification), and structure sharing (by","an equivalence closure taken over the nodes of the","arguments). For large TFSs, unification is compu-","tationally expensive, since all the nodes of the two","TFSs are visited. In this process, many nodes are","collapsed into equivalence classes because of struc-","ture sharing. A node x in a TFS F with root qF and","a node x","in a TFS F","with root qF","are equivalent","( ) with respect to F","F","iff x","qF and x","qF",",","or if there is a path p such that dF","F","","p","qF","x and","dF F","","p","qF","","x",". NUMBER:PERSON: GENDER: masculine third [1]singular NUMBER:PERSON: GENDER: third neuter[1] throwing THROWER: index","THROWN: index Figure 2: A TFS. Features are written in uppercase, while types are written with bold-face lowercase. Structure sharing is indicated by numerical tags, such as [1]. THROWER: THROWN: index index","masculine feminine neuter singular plural first second third numgend pers PERSON: GENDER:NUMBER: pers num gend","throwing index Figure 3: A type signature. For each type, appropriateness declares the features that must be definedon TFSs of that type, along with the type restrictions applying to their values. 2.2 Structure Sharing in Descriptions TFSGs are typically specified using descriptions, which logically denote sets of TFSs. Descriptions can be more terse because they can assume all of the information about their TFSs that can be in-ferred from appropriateness. Each non-disjunctive description can be associated with a unique most general feature structure in its denotation called a most general satisfier (MGSat). While a formal presentation can be found in (Carpenter, 1992), we limit ourselves to an intuitive example: the TFS from Figure 2 is the MGSat of the description: throwing","THROWER :","PERSON : third","NUMBER :  singular","Nr","","GENDER : masculine","","THROWN :  PERSON : third","NUMBER : Nr","GENDER : neuter",". Descriptions can also contain variables, such as Nr.","Structure sharing is enforced in descriptions through the use of variables. In TFSGs, the scope of a variable extends beyond a single description, resulting in structure sharing between different TFSs. In phrase structure rules (Figure 1), this sharing can occur between different daughter categories in a rule, or between a mother and a daughter. Unless the term description is explicitly used, we will use “mother” and “daughter” to refer to the MGSat of a mother or daughter description.","We can classify instances of variables based on what type of structure sharing they create. Inter-nal variables are the variables that represent internal structure sharing (such as in Figure 2). The occurrences of such variables are limited to a single category in a phrase structure rule. External variables are the variables used to share structure between categories. If a variable is used for structure sharing both inside a category and across categories, then it is also considered an external variable. For a specific category, two kinds of external variable instances can be distinguished, depending on their occurrence relative to the parsing control strategy: active external variables and inactive external variables. Active external variables are instances of external variables that are shared between the description of a category D and one or more descriptions of categories in the same rule as D visited by the parser before D as the rule is extended (completed). Inactive external variables are the external variable instances that are not active. For example, in bottom-up left-to-right parsing, all of a mother’s external variable instances would be active because, being external, they also occur in one of the daughter descriptions. Similarly, all of the leftmost daughter’s external variable instances would be inactive because this is the firstdescription used by the parser. In Figure 1, Agr is an active external variable in the second daughter, but it is inactive in the firstdaughter.","The active external variable instances are important for path indexing (Section 4.2), because they represent the points at which the parser must copy structure between TFSs. They are therefore substructures that must be provided to a rule by the parsing chart if these unifications could potentially fail. They also represent shared nodes in the MGSats of a rule’s category descriptions. In our definitions, we assume without loss of generality that parsing proceeds bottom-up, with left-to-right of rule daughters. This is the ALE system’s (Carpenter and Penn, 1996) parsing strategy. Definition 1. If D1","","","Dn are daughter descriptions in a rule and the rules are extended from left to right, then Ext","MGSat","Di","is the set of nodes shared between MGSat","Di","and MGSat","D1","","MGSat","Di","1",". For a mother description M, Ext","MGSat","M","is the set of nodes shared with any daughter in the same rule.","Because the completion of TFSG rules can cause the categories to change in structure (due to external variable sharing), we need some extra notation to refer to a phrase structure rule’s categories at different times during a single application of that rule. By ","M we symbolize the mother M after M’s rule is completed (all of the rule’s daughters are matched with edges in the chart). ","D symbolizes the daughter D after all daughters to D’s left in D’s rule were unifiedwith edges from the chart. An important relation exists between M and ","M: if qM is M’s root and qM is  M’s root, then ","x M   x ","M such that p for","which d","p","qM","","x and d","p ","qM  ","x, q x ","q ","x",". In other words, extending the rule extends the information states of its categories monotonically. A similar relation exists between D and  D. The set of","all nodes x in M such that","p for which d","p","qM","","x","and d","p ","qM   x will be denoted by  x  1","(and likewise for nodes in D). There may be more than one node in  x  1","because of unificationsthat occur during the extension of M to  M."]},{"title":"3 The Indexing Timeline","paragraphs":["Indexing can be applied at several moments during parsing. We introduce a general strategy for indexed parsing, with respect to what actions should be taken at each stage.","Three main stages can be identified. The first one consists of indexing actions that can be taken off-line (along with other optimizations that can be performed at compile-time). The second and third stages refer to actions performed at run time.","Stage 1. In the off-line phase, a static analysis of grammar rules can be performed. The complete content of mothers and daughters may not be accessible, due to variables that will be instantiated during parsing, but various sources of information, such as the type signature, appropriateness specifications, and the types and features of mother and daughter descriptions, can be analyzed and an appropriate indexing scheme can be specified. This phase of indexing may include determining: (1a) which daughters in which rules will certainly not unify with a specificmother, and (1b) what information can be extracted from categories during parsing that can constitute indexing keys. It is desirable to perform as much analysis as possible off-line, since the cost of any action taken during run time prolongs the parsing time.","Stage 2. During parsing, after a rule has been completed, all variables in the mother have been extended as far as they can be before insertion into the chart. This offers the possibility of further in-vestigating the mother’s content and extracting supplemental information from the mother that contributes to the indexing keys. However, the choice of such investigative actions must be carefully studied, since it might burden the parsing process.","Stage 3. While completing a rule, for each daughter a matching edge is searched in the chart. At this moment, the daughter’s active external variables have been extended as far as they can be before unification with a chart edge. The information identified in stage (1b) can be extracted and unified as a precursor to the remaining steps involved in category unification. These steps also take place at this stage."]},{"title":"4 TFSG Indexing","paragraphs":["To reduce the time spent on failures when searching for an edge in the chart, each edge (edge’s category) has an associated index key which uniquely identifiesthe set of daughter categories that can potentially match it. When completing a rule, edges unifying with a specificdaughter are searched for in the chart. Instead of visiting all edges in the chart, the daughter’s index key selects a restricted number of edges for traversal, thus reducing the number of unificationattempts.","The passive edges added to the chart represent specializations of rules’ mothers. When a rule is completed, its mother M is added to the chart according to M’s indexing scheme, which is the set of index keys of daughters that might possibly unify with M. The index is implemented as a hash, where the hash function applied to a daughter yields the daughter’s index key (a selection of chart edges). For a passive edge representing M, M’s indexing scheme provides the collection of hash entries where it will be added.","Each daughter is associated with a unique index key. During parsing, a specificdaughter is searched for in the chart by visiting only those edges that have a matching key, thus reducing the time needed for traversing the chart. The index keys can be computed off-line (when daughters are indexed by position), or during parsing. 4.1 Positional Indexing In positional indexing, the index key for each daughter is represented by its position (rule number and daughter position in the rule). The structure of the index can be determined at compile-time (first stage). For each mother M in the grammar, a collection"]},{"title":"L","paragraphs":["M","","  Ri","D j","","daughters that can match M","is","created (M’s indexing scheme), where each element","of"]},{"title":"L","paragraphs":["M","represents the rule number Ri and daughter","position D j inside rule Ri (1","j","arity","Ri",") of a","category that can match with M. For TFSGs it is not possible to compute off-line","the exact list of mother-daughter matching pairs, but","it is possible to rule out certain non-unifiable pairs","before parsing — a compromise that pays off with a","very low index management time. During parsing, each time an edge (representing","a rule’s mother M) is added to the chart, it is in-","serted into the hash entries associated with the po-","sitions","Ri","D j","from the list"]},{"title":"L","paragraphs":["M","(the number of","entries where M is inserted is"]},{"title":"L","paragraphs":["M","","). The entry associated with the key","Ri","D j","will contain only categories that can possibly unify with the daughter at position","Ri","D j","in the grammar.","Because our parsing algorithm closes categories depth-first under leftmost daughter matching, only daughters Di with i","2 are searched for in the chart (and consequently, indexed). We used the EFD-based modification of this algorithm (Penn and Munteanu, 2003), which needs no active edges, and requires a constant two copies per edges, rather than the standard one copy per retrieval found in Prolog parsers. Without this, the cost of copying TFS categories would have overwhelmed the benefitof the index. 4.2 Path Indexing Path indexing is an extension of positional indexing. Although it shares the same underlying principle as the path indexing used in automated reasoning (Ramakrishnan et al., 2001), its functionality is related to quick check: extract a vector of types from a mother (which will become an edge) and a daughter, and test the unification of the two vectors before attempting to unify the edge and the daughter. Path indexing differs from quick-check in that it identifiesthese paths by a static analysis of grammar rules, performed off-line and with no training required. Path indexing is also built on top of positional indexing, therefore the vector of types can be different for each potentially unifiable mother-daughter pair. 4.2.1 Static Analysis of Grammar Rules Similar to the abstract interpretation used in program verification (Cousot and Cousot, 1992), the static analysis tries to predict a run-time phenomenon (specifically, unification failures) at compile-time. It tries to identify nodes in a mother that carry no relevant information with respect to unification with a particular daughter. For a mother M unifiable with a daughter D, these nodes will be grouped in a set StaticCut","M","D",". Intuitively, these nodes can be left out or ignored while computing the unification of  M and ","D. The StaticCut","can be divided into two subsets: StaticCut","M","D","","RigidCut","M D","","VariableCut","M","D","","The RigidCut represents nodes that can be left out","because neither they, nor one of their dp-ancestors,","can have their type values changed by means of ex-","ternal variable sharing. The VariableCut represents","nodes that are either externally shared, or have an","externally shared ancestor, but still can be left out.","Definition 2. RigidCut","M","D","is the largest subset","of nodes x M such that, ","y","D for which x","y:","1. x","","Ext","M",", y ","Ext","D",",","2. ","x","","M s.t.","p s.t. d","p","x  ","x, x","","","Ext","M",", and 3. ","y","","D s.t.","p s.t. d","p","y  ","y, y","","","Ext","D",".","Definition 3. VariableCut is the largest subset of","nodes x","M such that:","1. x  RigidCut","M","D",", and","2. ","y D for which x","y, ","s q x"," ","t q y",",","s t exists.","In words, a node can be left out even if it is externally shared (or has an externally shared ancestor) if all possible types this node can have unify with all possible types its corresponding nodes in D can have. Due to structure sharing, the types of nodes in M and D can change during parsing, by being specialized to one of their subtypes. Condition 2 ensures that the types of these nodes will re-main compatible (have a least upper bound), even if they specialize during rule completion. An intuitive example (real-life examples cannot be reproduced here — a category in a typical TFSG can have hundreds of nodes) is presented in Figure 4. y2 y1","y3 y5 t1 t6 t6","y4 t1 t5 F: G: H: G: K: Dx1 x2 x3 x4","F: H: G: I:","t7 t7 t3 t1 G:t1 H:t6 F:t6 K:t1I:t3 t1 t5 t3 G:t5 t4 t2 J:t5 t7 t6 t0 T t8 M Figure 4: Given the above type signature, mother M and daughter D (externally shared nodes are pointed to by dashed arrows), nodes x1","x2","and x3 from M can be left out when unifying M with D during parsing. x1 and x3 ","RigidCut M D",", while x2  VariableCut","M","D","(q","y2","can promote only to t7, thus x2 and y2 will always be","compatible). x4 is not included in the StaticCut, because","if q","y5","promotes to t5, then q y4","will promote to t5 (not","unifiablewith t3).","When computing the unification between a mother and a daughter during parsing, the same out-come (success or failure) will be reached by using a reduced representation of the mother ( ","Ms","D","), with","nodes in StaticCut","M","D removed from  M. Proposition 1. For a mother M and a daughter D, if M","D  before parsing, and  M (as an edge in the chart) and  D exist, then during parsing: (1)  Ms D",""," D    M  D  , (2) ","Ms D  ","D   M ","D . Proof. The second part ( ","Ms D  ","D   M ","D",")","of Proposition 1 has a straightforward proof: if","Ms D  ","D , then  z ","Ms D  ","D such that  t for which  ","x  ","z","  t","q ","x . Since ","Ms D  M, ","z  M ","D such that  t for which  ","x  ","z   t","q ","x , and therefore,  M ","D",".","The firstpart of the proposition will be proven by","showing that   z  M  D, a consistent type can be assigned to  z ",", where  z ","is the set of nodes in  M and  D equivalent to  z with respect to the unification of  M and ","D.1 Three lemmata need to be formulated:","Lemma 1. If  x ","M and x   x  1 , then q ","x"," q","x",". Similarly, for  y ","D, y   y  1 , q ","y","","q","y",".","Lemma 2. If types t0","t1","","","tn are such that  t 0 t0 ","i","","1","  n",", t","0","ti ",", then t","t0 such that  i","","1","  n",", t","ti. 1","Because we do not assume inequated TFSs (Carpenter, 1992) here, unification failure must result from type inconsistency. Lemma 3. If  x  M and  y  D for which  x  y, then  x","  x  1   y","  y  1","such that x y. In proving the first part of Proposition 1, four","cases are identified: Case A:","  z  "," ","M ","1 and    z  "," ","D","","1, Case B:","  z "," ","M  1 and","  z   ","D  1, Case C:","  z  "," ","M  1 and","  z "," ","D ","1,","Case D:   z "," ","M  1 and","  z ","  D","","1. Case A","is trivial, and D is a generalization of B and C.","Case B. It will be shown that","t Type such that  ","y   z  ","  D and for ","x ","  z "," ","M, t q ","y and","t q  x",".","Subcase B.i:  x  M ","x ","","Ms D .","","y","  z "," ","D, y ","x. Therefore, according to Lemma 3, x   x  1   y","  y  1 such that x","y. Thus, according","to Condition 2 of Definition3, ","s q y"," ","t q x",",","s t  . But according to Lemma 1, q ","y"," q","y","and q ","x"," q","x",". Therefore,  ","y   z ","  D, ","s q ","y , ","t q ","x , s","t  , and hence,  ","y   z ","  D  t q ","x  t","q  y ",". Thus, according to Lemma 2, t q ","x   ","y   z  "," ","D, t q ","y . Subcase B.ii:  x  M  x ","Ms D . Since ","Ms D   D  ,  t","q ","x such that  ","y   z "," ","D, t q  y",".","Case C. It will be shown that","t q ","y such that  ","x  ","z  , t","q ","x . Let ","y ","  z  ","  D. The set  z ","  M can be divided into two subsets: Sii  ","x   z ","  M  x ","Ms D  , and S","i  ","x   z ","  M ","x  M ","x  ","Ms","D",", and x VariableCut","M","D","",". If x","were in RigidCut","M D , then necessarily","  z ","  M would be 1. Since Sii ","Ms D","and ","Ms D   D  , then"," t ","q ","y such that  ","x","Sii t","","q ","x (*). However,  ","x Sii,  x  y. Therefore, according to Lemma 3,  ","x","Sii  x","  x  1   y","  y  1","such that","x","y. Thus, since x VariableCut","M","D",", Condi-","tion 2 of Definition 3 holds, and therefore, accord-","ing to Lemma 1, ","s1 q ","x  ","s2 q ","y  s1","s2  .","More than this, since t ","q ","y (for the type t","from (*)), ","s1 q ","x  ","s","2 t  s1","s","2  , and hence,  s 2","t  s 2","q  x ",". Thus, according to Lemma 2 and to","(*),","t t ","q ","y such that  ","x Sii t","q ","x  Thus,  t such that  ","x  ","z  , t","q ","x .","While Proposition 1 could possibly be used by grammar developers to simplify TFSGs themselves at the source-code level, here we only exploit it for internally identifying index keys for more efficient chart parsing with the existing grammar. There may be better static analyses, and better uses of this static analysis. In particular, future work will focus on using static analysis to determine smaller representations (by cutting nodes in Static Cuts) of the chart edges themselves. 4.2.2 Building the Path Index The indexing schemes used in path indexing are built on the same principles as those in positional indexing. The main difference is the content of the indexing keys, which now includes a third element. Each mother M has its indexing scheme definedas:"]},{"title":"L","paragraphs":["M  ","Ri","D j","Vi","j","",". The pair","Ri","D j","is the po-","sitional index key (as in positional indexing), while","Vi","j is the path index vector containing type values","extracted from M. A different set of types is ex-","tracted for each mother-daughter pair. So, path in-","dexing uses a two-layer indexing method: the po-","sitional key for daughters, and types extracted from","the typed feature structure. Each daughter’s index","key is now given by"]},{"title":"L","paragraphs":["D j","","","","Ri","Vi","j","",", where Ri","is the rule number of a potentially matching mother,","and Vi","j is the path index vector containing types ex-","tracted from D j.","The types extracted for the indexing vectors","are those of nodes found at the end of indexing","paths. A path p is an indexing path for a mother-","daughter pair","M D","iff: (1) p is definedfor both M","and D, (2)","x StaticCut","M","D","","","f s.t. d","f","x","","d","p","qM","(qM is M’s root), and (3) d","p","qM","","","StaticCut","M","D . Indexing paths are the “frontiers”","of the non-statically-cut nodes of M.","A similar key extraction could be performed dur-","ing Stage 2 of indexing (as outlined in Section 3),","using ","M rather than M. We have found that this on-","line path discovery is generally too expensive to be","performed during parsing, however. As stated in Proposition 1, the nodes in","StaticCut","M","D","do not affect the success/failure","of  M ","D. Therefore, the types of first nodes not included in StaticCut","M","D","along each path p that stems from the root of M and D are included in the indexing key, since these nodes might contribute to the success/failure of the unification. It should be mentioned that the vectors Vi","j are filled with values extracted from  M after M’s rule is completed, and from ","D after all daugh-","ters to the left of D are unified with edges in the","chart. As an example, assuming that the index-","ing paths are THROWER:PERSON, THROWN, and","THROWN:GENDER, the path index vector for the","TFS shown in Figure 2 is","third","index","neuter",". 4.2.3 Using the Path Index Inserting and retrieving edges from the chart using path indexing is similar to the general method presented at the beginning of this section. The first layer of the index is used to insert a mother as an edge into appropriate chart entries, according to the positional keys for the daughters it can match. Along with the mother, its path index vector is inserted into the chart.","When searching for a matching edge for a daughter, the search is restricted by the firstindexing layer to a single entry in the chart (labeled with the positional index key for the daughter). The second layer restricts searches to the edges that have a compatible path index vector. The compatibility is defined as type unification: the type pointed to by the element Vi","j","n","of an edge’s vector Vi","j should unify with the type pointed to by the element Vi","j","n","of the path index vector Vi","j of the daughter on position D j in a rule Ri."]},{"title":"5 Experimental Evaluation","paragraphs":["Two TFSGs were used to evaluate the performance of indexing: a pre-release version of the MERGE grammar, and the ALE port of the ERG (in its final form). MERGE is an adaptation of the ERG which uses types more conservatively in favour of relations, macros and complex-antecedent constraints. This pre-release version has 17 rules, 136 lexical items, 1157 types, and 144 introduced features. The ERG port has 45 rules, 1314 lexical entries, 4305 types and 155 features. MERGE was tested on 550 sentences of lengths between 6 and 16 words, extracted from the Wall Street Journal annotated parse trees (where phrases not covered by MERGE’s vocabulary were replaced by lexical entries having the same parts of speech), and from MERGE’s own test corpus. ERG was tested on 1030 sentences of lengths between 6 and 22 words, extracted from the Brown Corpus and from the Wall Street Journal annotated parse trees.","Rather than use the current version of ALE, TFSs were encoded as Prolog terms as prescribed in (Penn, 1999a), where the number of argument positions is the number of colours needed to colour the feature graph. This was extended to allow for the enforcement of type constraints during TFS unification. Types were encoded as attributed variables in SICStus Prolog (Swedish Institute of Computer Science, 2004). 5.1 Positional and path indexing evaluation The average and best improvements in parsing times of positional and path indexing over the same EFD-based parser without indexing are presented in Table 1. The parsers were implemented in SICStus 3.10.1 for Solaris 8, running on a Sun Server with 16 GB of memory and 4 UltraSparc v.9 processors at 1281 MHz. For MERGE, parsing times range from 10 milliseconds to 1.3 seconds. For ERG, parsing times vary between 60 milliseconds and 29.2 seconds.","Positional Index Path Index","average best average best MERGE 1.3% 50% 1.3% 53.7% ERG 13.9% 36.5% 12% 41.6%","Table 1: Parsing time improvements of positional and","path indexing over the non-indexed EFD parser. 5.2 Comparison with statistical optimizations Non-statistical optimizations can be seen as a first step toward a highly efficientparser, while statistical optimization can be applied as a second step. However, one of the purposes of non-statistical indexing is to eliminate the burden of training while of-fering comparable improvements in parsing times. A quick-check parser was also built and evaluated and the set-up times for the indexed parsers and the quick-check parser were compared (Table 2). Quick-check was trained on a 300-sentence training corpus, as prescribed in (Malouf et al., 2000). The training corpus included 150 sentences also used in testing. The number of paths in path indexing is different for each mother-daughter pair, ranging from 1 to 43 over the two grammars.","Positional Path Quick","Index Index Check Compiling grammar 6’30”","Compiling index 2” 1’33” -","Training - - 3h28’14”","Total set-up time: 6’32” 8’3” 3h34’44” Table 2: The set-up times for non-statistically indexed parsers and statistically optimized parsers for MERGE.","As seen in Table 3, quick-check alone surpasses positional and path indexing for the ERG. However, it is outperformed by them on the MERGE, recording slower times than even the baseline. But the combination of quick-check and path indexing is faster than quick-check alone on both grammars. Path indexing at best provided no decrease in performance over positional indexing alone in these experiments, attesting to the difficulty of maintaining efficientindex keys in an implementation.","Positional Path Quick Quick +","Indexing Indexing Check Path MERGE 1.3% 1.3% -4.5% -4.3%","ERG 13.9% 12% 19.8% 22% Table 3: Comparison of average improvements over non-indexed parsing among all parsers.","The quick-check evaluation presented in (Malouf et al., 2000) uses only sentences with a length of at most 10 words, and the authors do not report the set-up times. Quick-check has an additional advantage in the present comparison, because half of the training sentences were included in the test corpus.","While quick-check improvements on the ERG confirm other reports on this method, it must be Grammar Successful Failed unifications Failure rate reduction (vs. no index)","unifications EFD Positional Path Quick Positional Path Quick","non-indexed Index Index Check Index Index Check MERGE 159 755 699 552 370 7.4% 26.8% 50.9% ERG 1078 215083 109080 108610 18040 49.2% 49.5% 91.6%","Table 4: The number of successful and failed unificationsfor the non-indexed, positional indexing, path indexing, and","quick-check parsers, over MERGE and ERG (collected on the slowest sentence in the corresponding test sets.) noted that quick-check appears to be parochially very well-suited to the ERG (indeed quick-check was developed alongside testing on the ERG). Although the recommended first 30 most probable failure-causing paths account for a large part of the failures recorded in training on both grammars (94% for ERG and 97% for MERGE), only 51 paths caused failures at all for MERGE during training, compared to 216 for the ERG. Further training with quick-check for determining a better vector length for MERGE did not improve its performance.","This discrepancy in the number of failure-causing paths could be resulting in an overfittedquick-check vector, or, perhaps the 30 paths chosen for MERGE really are not the best 30 (quick-check uses a greedy approximation). In addition, as shown in Table 4, the improvements made by quick-check on the ERG are explained by the drastic reduction of (chart lookup) unificationfailures during parsing relative to the other methods. It appears that nothing short of a drastic reduction is necessary to justify the overhead of maintaining the index, which is the largest for quick-check because some of its paths must be traversed at run-time — path indexing only uses paths available at compile-time in the grammar source. Note that path indexing outperforms quick-check on MERGE in spite of its lower failure reduction rate, because of its smaller overhead."]},{"title":"6 Conclusions and Future Work","paragraphs":["The indexing method proposed here is suitable for several classes of unification-based grammars. The index keys are determined statically and are based on an a priori analysis of grammar rules. A major advantage of such indexing methods is the elimination of the lengthy training processes needed by statistical methods. Our experimental evaluation demonstrates that indexing by static analysis is a promising alternative to optimizing parsing with TFSGs, although the time consumed by on-line maintenance of the index is a significantconcern — echoes of an observation that has been made in applications of term indexing to databases and programming languages (Graf, 1996). Further work on efficient implementations and data structures is therefore required. Indexing by static analysis of grammar rules combined with statistical methods also can provide a higher aggregate benefit.","The current static analysis of grammar rules used as a basis for indexing does not consider the effect of the universally quantified constraints that typically augment the signature and grammar rules. Fu-ture work will investigate this extension as well."]},{"title":"References","paragraphs":["B. Carpenter and G. Penn. 1996. Compiling typed attribute-value logic grammars. In H. Bunt and M. Tomita, editors, Recent Advances in Parsing Technologies, pages 145–168. Kluwer.","B. Carpenter. 1992. The Logic of Typed Feature Structures. Cambridge University Press.","P. Cousot and R. Cousot. 1992. Abstract interpretation and application to logic programs. Journal of Logic Programming, 13(2–3).","R. Elmasri and S. Navathe. 2000. Fundamentals of database systems. Addison-Wesley.","D. Flickinger. 1999. The English Resource Grammar. http://lingo.stanford.edu/erg.html.","P. Graf. 1996. Term Indexing. Springer.","B. Kiefer, H.U. Krieger, J. Carroll, and R. Malouf. 1999. A bag of useful techniques for efficientand robust parsing. In Proceedings of the 37th Annual Meeting of the ACL.","R. Malouf, J. Carrol, and A. Copestake. 2000. Efficient feature structure operations without compilation. Natural Language Engineering, 6(1).","G. Penn and C. Munteanu. 2003. A tabulation-based parsing method that reduces copying. In Proceedings of the 41st Annual Meeting of the ACL, Sapporo, Japan.","G. Penn. 1999a. An optimised Prolog encoding of typed feature structures. Technical Report 138, SFB 340, Tübingen.","G. Penn. 1999b. Optimising don’t-care nondeterminism with statistical information. Technical Report 140, SFB 340, Tübingen.","C. Pollard and I. Sag. 1994. Head-driven Phrase Structure Grammar. The University of Chicago Press.","I.V. Ramakrishnan, R. Sekar, and A. Voronkov. 2001. Term indexing. In Handbook of Automated Reasoning, volume II, chapter 26. Elsevier Science.","Swedish Institute of Computer Science. 2004. SICStus Prolog 3.11.0. http://www.sics.se/sicstus."]}],"references":[{"authors":[{"first":"B.","last":"Carpenter"},{"first":"G.","last":"Penn"}],"year":"1996","title":"Compiling typed attribute-value logic grammars","source":"B. Carpenter and G. Penn. 1996. Compiling typed attribute-value logic grammars. In H. Bunt and M. Tomita, editors, Recent Advances in Parsing Technologies, pages 145–168. Kluwer."},{"authors":[{"first":"B.","last":"Carpenter"}],"year":"1992","title":"The Logic of Typed Feature Structures","source":"B. Carpenter. 1992. The Logic of Typed Feature Structures. Cambridge University Press."},{"authors":[{"first":"P.","last":"Cousot"},{"first":"R.","last":"Cousot"}],"year":"1992","title":"Abstract interpretation and application to logic programs","source":"P. Cousot and R. Cousot. 1992. Abstract interpretation and application to logic programs. Journal of Logic Programming, 13(2–3)."},{"authors":[{"first":"R.","last":"Elmasri"},{"first":"S.","last":"Navathe"}],"year":"2000","title":"Fundamentals of database systems","source":"R. Elmasri and S. Navathe. 2000. Fundamentals of database systems. Addison-Wesley."},{"authors":[{"first":"D.","last":"Flickinger"}],"year":"1999","title":"The English Resource Grammar","source":"D. Flickinger. 1999. The English Resource Grammar. http://lingo.stanford.edu/erg.html."},{"authors":[{"first":"P.","last":"Graf"}],"year":"1996","title":"Term Indexing","source":"P. Graf. 1996. Term Indexing. Springer."},{"authors":[{"first":"B.","last":"Kiefer"},{"first":"H.","middle":"U.","last":"Krieger"},{"first":"J.","last":"Carroll"},{"first":"R.","last":"Malouf"}],"year":"1999","title":"A bag of useful techniques for efficientand robust parsing","source":"B. Kiefer, H.U. Krieger, J. Carroll, and R. Malouf. 1999. A bag of useful techniques for efficientand robust parsing. In Proceedings of the 37th Annual Meeting of the ACL."},{"authors":[{"first":"R.","last":"Malouf"},{"first":"J.","last":"Carrol"},{"first":"A.","last":"Copestake"}],"year":"2000","title":"Efficient feature structure operations without compilation","source":"R. Malouf, J. Carrol, and A. Copestake. 2000. Efficient feature structure operations without compilation. Natural Language Engineering, 6(1)."},{"authors":[{"first":"G.","last":"Penn"},{"first":"C.","last":"Munteanu"}],"year":"2003","title":"A tabulation-based parsing method that reduces copying","source":"G. Penn and C. Munteanu. 2003. A tabulation-based parsing method that reduces copying. In Proceedings of the 41st Annual Meeting of the ACL, Sapporo, Japan."},{"authors":[{"first":"G.","last":"Penn"}],"year":"1999a","title":"An optimised Prolog encoding of typed feature structures","source":"G. Penn. 1999a. An optimised Prolog encoding of typed feature structures. Technical Report 138, SFB 340, Tübingen."},{"authors":[{"first":"G.","last":"Penn"}],"year":"1999b","title":"Optimising don’t-care nondeterminism with statistical information","source":"G. Penn. 1999b. Optimising don’t-care nondeterminism with statistical information. Technical Report 140, SFB 340, Tübingen."},{"authors":[{"first":"C.","last":"Pollard"},{"first":"I.","last":"Sag"}],"year":"1994","title":"Head-driven Phrase Structure Grammar","source":"C. Pollard and I. Sag. 1994. Head-driven Phrase Structure Grammar. The University of Chicago Press."},{"authors":[{"first":"I.","middle":"V.","last":"Ramakrishnan"},{"first":"R.","last":"Sekar"},{"first":"A.","last":"Voronkov"}],"year":"2001","title":"Term indexing","source":"I.V. Ramakrishnan, R. Sekar, and A. Voronkov. 2001. Term indexing. In Handbook of Automated Reasoning, volume II, chapter 26. Elsevier Science."},{"authors":[{"first":"Swedish","middle":"Institute of Computer","last":"Science"}],"year":"2004","title":"SICStus Prolog 3","source":"Swedish Institute of Computer Science. 2004. SICStus Prolog 3.11.0. http://www.sics.se/sicstus."}],"cites":[{"style":0,"text":"Pollard and Sag, 1994","origin":{"pointer":"/sections/1/paragraphs/0","offset":516,"length":21},"authors":[{"last":"Pollard"},{"last":"Sag"}],"year":"1994","references":["/references/11"]},{"style":0,"text":"Carpenter, 1992","origin":{"pointer":"/sections/1/paragraphs/1","offset":419,"length":15},"authors":[{"last":"Carpenter"}],"year":"1992","references":["/references/1"]},{"style":0,"text":"Penn and Munteanu, 2003","origin":{"pointer":"/sections/1/paragraphs/2","offset":121,"length":23},"authors":[{"last":"Penn"},{"last":"Munteanu"}],"year":"2003","references":["/references/8"]},{"style":0,"text":"Malouf et al., 2000","origin":{"pointer":"/sections/1/paragraphs/2","offset":344,"length":19},"authors":[{"last":"Malouf"},{"last":"al."}],"year":"2000","references":["/references/7"]},{"style":0,"text":"Flickinger, 1999","origin":{"pointer":"/sections/1/paragraphs/2","offset":695,"length":16},"authors":[{"last":"Flickinger"}],"year":"1999","references":["/references/4"]},{"style":0,"text":"Penn, 1999b","origin":{"pointer":"/sections/1/paragraphs/2","offset":730,"length":11},"authors":[{"last":"Penn"}],"year":"1999b","references":["/references/10"]},{"style":0,"text":"Kiefer et al., 1999","origin":{"pointer":"/sections/1/paragraphs/4","offset":31,"length":19},"authors":[{"last":"Kiefer"},{"last":"al."}],"year":"1999","references":["/references/6"]},{"style":0,"text":"Elmasri and Navathe, 2000","origin":{"pointer":"/sections/1/paragraphs/4","offset":628,"length":25},"authors":[{"last":"Elmasri"},{"last":"Navathe"}],"year":"2000","references":["/references/3"]},{"style":0,"text":"Ramakrishnan et al., 2001","origin":{"pointer":"/sections/1/paragraphs/4","offset":680,"length":25},"authors":[{"last":"Ramakrishnan"},{"last":"al."}],"year":"2001","references":["/references/12"]},{"style":0,"text":"Carpenter, 1992","origin":{"pointer":"/sections/2/paragraphs/0","offset":108,"length":15},"authors":[{"last":"Carpenter"}],"year":"1992","references":["/references/1"]},{"style":0,"text":"Carpenter, 1992","origin":{"pointer":"/sections/2/paragraphs/83","offset":661,"length":15},"authors":[{"last":"Carpenter"}],"year":"1992","references":["/references/1"]},{"style":0,"text":"Carpenter and Penn, 1996","origin":{"pointer":"/sections/2/paragraphs/97","offset":542,"length":24},"authors":[{"last":"Carpenter"},{"last":"Penn"}],"year":"1996","references":["/references/0"]},{"style":0,"text":"Penn and Munteanu, 2003","origin":{"pointer":"/sections/8/paragraphs/10","offset":115,"length":23},"authors":[{"last":"Penn"},{"last":"Munteanu"}],"year":"2003","references":["/references/8"]},{"style":0,"text":"Ramakrishnan et al., 2001","origin":{"pointer":"/sections/8/paragraphs/10","offset":557,"length":25},"authors":[{"last":"Ramakrishnan"},{"last":"al."}],"year":"2001","references":["/references/12"]},{"style":0,"text":"Cousot and Cousot, 1992","origin":{"pointer":"/sections/8/paragraphs/10","offset":1240,"length":23},"authors":[{"last":"Cousot"},{"last":"Cousot"}],"year":"1992","references":["/references/2"]},{"style":0,"text":"Carpenter, 1992","origin":{"pointer":"/sections/8/paragraphs/180","offset":41,"length":15},"authors":[{"last":"Carpenter"}],"year":"1992","references":["/references/1"]},{"style":0,"text":"Penn, 1999a","origin":{"pointer":"/sections/11/paragraphs/1","offset":96,"length":11},"authors":[{"last":"Penn"}],"year":"1999a","references":["/references/9"]},{"style":0,"text":"Science, 2004","origin":{"pointer":"/sections/11/paragraphs/1","offset":393,"length":13},"authors":[{"last":"Science"}],"year":"2004","references":["/references/13"]},{"style":0,"text":"Malouf et al., 2000","origin":{"pointer":"/sections/11/paragraphs/5","offset":626,"length":19},"authors":[{"last":"Malouf"},{"last":"al."}],"year":"2000","references":["/references/7"]},{"style":0,"text":"Malouf et al., 2000","origin":{"pointer":"/sections/11/paragraphs/15","offset":41,"length":19},"authors":[{"last":"Malouf"},{"last":"al."}],"year":"2000","references":["/references/7"]},{"style":0,"text":"Graf, 1996","origin":{"pointer":"/sections/12/paragraphs/0","offset":662,"length":10},"authors":[{"last":"Graf"}],"year":"1996","references":["/references/5"]}]}
